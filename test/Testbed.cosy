// {
//     fn test() Str {} // TODO: Should fail because there is no return statements
//     print test()
// }

// @test('max of two positive numbers')
// test.eq(max(5, 6), 6)

// {
//     struct Point {   // Struct
//         mut x
//         var y
//     }
//     // instantiate struct
//     mut point = Point { x = 3, y = 4 }
// 
//     fn mutf(mut p Point) {
//         p.x = 5
//     }
//     print point
//     mutf(point) // TODO: Fail! Should be mut
//     print point
// }


// {
//     struct S {}
//     fn mutf(mut s S) {
//         print s
//     }
//     mut s = S {}
//     mutf(s) // TODO: Fail! Should be mut
// }


// {
//     // AST interpreter takes ~5 seconds on a 16" MacBook Pro
//     foreign fn random_int(n Num)

//     var n = 1000000
//     mut a = []
//     for 0..n {
//         a.push(0)
//     }
//     for 0..10 {
//         a[random_int(n)] = 1
//     }

//     var t0 = clock()
//     mut counter = 0
//     mut l = []
//     for j in 0..a.length {
//         if a[j] == 1 and a[j + 1] == 0 {
//             l.push(counter)
//         }
//         counter += 1
//     }
//     var t1 = clock()
//     print l
//     print 'Time spend: {(t1 - t0) / 1000} seconds'
// }

// fn reduce(arr Array Num, f Fn(Num, Num) Num, init Num) Num {
//     mut acc = init
//     for a in arr {
//         acc = f(acc, a)
//     }
//     return acc
// }

{
    // testing the bytecode code generator + disassembler + vm
    // print 'before function'
    // fn hello(x Num) {
    //     print 'hello from function'
    //     print x * x
    // }
    // print 'before call'
    // hello(4)
    // print 'after call'

    // var sum = reduce([1, 2, 3, 4, 5], fn(a, b) { return a + b }, 0)
    // var sum = [1, 2, 3, 4, 5].reduce(fn(a, b) { return a + b }, 0)
    // print sum
   
    // print 'answer: ' + 3
}

// {
//     struct Node {
//         var value Str = ''
//         var left
//         var right
//     }
   
//     fn serialize(node Node) Str {
//         if node == '' or node.value == '' return '-,'
//         mut s = node.value + ','
//         s += serialize(node.left)
//         s += serialize(node.right)
//         return s
//     }
    
//     fn deserialize(s Str) Node {
//         var parts = s.split(',')
//         mut index = 0
        
//         fn do_deserialize() {
//             // print 'do_deserialize'
//             if index >= parts.length return ''
//             var value = parts[index]
//             index += 1
//             if value == '-' return ''
//             return Node { value = value, left = do_deserialize(), right = do_deserialize() }
//         }
        
//         return do_deserialize()
//     }

//     // The following test should pass:

//     var node = Node {
//         value = 'root',
//         left = Node {
//             value = 'left',
//             left = Node { 
//                 value = 'left.left',
//                 left = '',
//                 right = '',
//             },
//             right = '',
//         }, 
//         right = Node {
//             value = 'right',
//             left = '',
//             right = '',
//         }
//     }
//     print serialize(node)
//     var n Node = deserialize(serialize(node))
//     var n1 Node = n.left
//     var n2 Node = n1.left
//     print n2.value
//     //#assert deserialize(serialize(node)).left.left.val == 'left.left'
// }

print 'start'
mut s = ['h', 'e', 'l', 'l', 'o']
print '1'
// s[2..] = 'world' // TODO: What should happen here? Type error?
// print s[2..]
print '2'
// s[2..] = ['world']
print s
print 'done'